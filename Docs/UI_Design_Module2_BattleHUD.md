# Project Harmony: UI 设计文档 - 模块2：战斗 HUD 系统

**版本:** 1.0  
**最后更新:** 2026-02-12  
**状态:** 初稿

> **文档定位：战斗信息中枢 (The "How")**
> 本文档是衔接《美术与VFX方向总文档》[1]与 Godot 引擎具体实现的桥梁，详细定义了【模块2：战斗 HUD 系统】中每一个 UI 元素的技术规格、布局、行为和实现策略。它回答了“我们如何将美术方向落地为功能性 UI？”的问题。

---

## 目录
1. [设计哲学与信息层级](#1-设计哲学与信息层级)
2. [全局布局与层级 (Z-Index)](#2-全局布局与层级-z-index)
3. [核心 HUD 元素详解](#3-核心-hud-元素详解)
    3.1. [谐振完整度 (血条)](#31-谐振完整度-血条)
    3.2. [听感疲劳指示器](#32-听感疲劳指示器)
    3.3. [序列器状态](#33-序列器状态)
    3.4. [手动施法槽](#34-手动施法槽)
    3.5. [信息面板](#35-信息面板)
    3.6. [伤害数字系统](#36-伤害数字系统)
    3.7. [Boss 血条主题化设计](#37-boss-血条主题化设计)
    3.8. [弹药环形 HUD](#38-弹药环形-hud)
    3.9. [召唤物 HUD](#39-召唤物-hud)
    3.10. [节拍指示器](#310-节拍指示器)
    3.11. [状态提示与警告](#311-状态提示与警告)
4. [Godot 实现总览](#4-godot-实现总览)
5. [参考资料](#5-参考资料)

---

## 1. 设计哲学与信息层级

战斗 HUD 的核心设计哲学是**“通感” (Synesthesia)**，即让玩家不仅能“读”到信息，更能“感受”到游戏的音乐状态。所有 UI 元素都不仅仅是信息的展示器，更是游戏核心机制“和谐 vs. 噪音”的视觉延伸。UI 的动态变化、节拍同步的脉动、故障艺术的介入，共同构成了一个与音乐同呼吸的沉浸式信息界面。

信息被划分为三个优先级层级，以决定其在屏幕上的显著程度：

| 优先级 | 信息类别 | 视觉特征 | 示例 |
| :--- | :--- | :--- | :--- |
| **第一层 (生存)** | 玩家的直接生存状态 | 尺寸大，位于屏幕中央区域，动态变化剧烈，与节拍强同步 | 谐振完整度 (血条)、听感疲劳指示器、序列器状态 |
| **第二层 (行动)** | 玩家的核心战斗选择与资源 | 尺寸中等，位于屏幕边缘或玩家周围，有清晰的冷却/状态反馈 | 手动施法槽、弹药环、召唤物 HUD |
| **第三层 (数据)** | 辅助性的统计与环境数据 | 尺寸小，位于屏幕角落，静态或低频更新 | BPM/时间/等级/敌人数量信息面板 |

## 2. 全局布局与层级 (Z-Index)

HUD 元素被组织在不同的 `CanvasLayer` 上，以确保清晰的渲染顺序和逻辑分离。所有坐标均以 1920x1080 分辨率为基准。

| 元素 | 位置 (锚点) | 尺寸 (估算) | CanvasLayer / Z-Index | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| 谐振完整度 | `Bottom-Wide` | 800x150 px | `Layer 10` | 屏幕正下方，弧形，玩家视觉焦点 |
| 听感疲劳指示器 | `Center-Right` | 20x400 px | `Layer 10` | 屏幕右侧垂直条，便于快速扫视 |
| 序列器状态 | 玩家角色上方 | 200x200 px (环形) | `Layer 5` (游戏世界内) | 跟随玩家移动，作为游戏场景的一部分 |
| 手动施法槽 | `Bottom-Left` | 240x80 px | `Layer 10` | 屏幕左下角，传统快捷键位置 |
| 信息面板 | `Top-Left` | 200x100 px | `Layer 10` | 屏幕左上角，不妨碍主视野 |
| 伤害数字 | 动态生成 | 动态 | `Layer 6` (游戏世界内) | 在伤害事件发生的位置生成 |
| Boss 血条 | `Top-Wide` | 1000x120 px | `Layer 10` | 屏幕正上方，压迫感强 |
| 弹药环 HUD | 玩家角色周围 | 250x250 px (环形) | `Layer 5` (游戏世界内) | 包围序列器状态环，提供武器信息 |
| 召唤物 HUD | `Top-Right` | 180x300 px | `Layer 10` | 屏幕右上角，卡片式列表 |
| 节拍指示器 | 玩家角色下方 | 100x100 px | `Layer 5` (游戏世界内) | 紧贴玩家，提供核心节奏参考 |
| 状态提示 | 动态生成 | 动态 | `Layer 11` (最顶层) | 在屏幕中央或关键位置弹出，吸引注意力 |


## 3. 核心 HUD 元素详解

### 3.1. 谐振完整度 (血条)

谐振完整度是玩家生命值的核心视觉表现，其设计旨在将“生命”这一概念从单纯的数值转化为可感的“音乐谐振状态”。

谐振完整度作为玩家生存状态的核心指示器，其**布局位于屏幕正下方**，并采用 `Bottom-Wide` 锚点。为了最大化信息可见性同时最小化对核心战斗区域的遮挡，它被设计成一个宽广的**弧形**，优雅地环绕屏幕底部中心。其**基准尺寸**设定为 800px 宽度和 150px 高度，此高度已包含辉光及其他动态效果所需的额外空间。在渲染层级上，它被放置在 `Layer 10` 的 `CanvasLayer` 上，确保其显示在绝大多数游戏世界元素之上。

#### 状态变化的视觉表现

血条的形态和颜色与玩家当前的生命值百分比直接关联，体现从“和谐”到“噪音”的平滑过渡。

| 生命值 % | 形态 | 颜色 | 动画/VFX | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| **100%** | **平滑正弦波** | **谐振青** (`#00FFD4`) | 振幅随节拍微弱脉动，伴有柔和的辉光。 | 完美的谐振状态，稳定而有序。 |
| **75%-99%** | 正弦波，略有抖动 | 青色，饱和度略降 | 辉光减弱，波形出现轻微的不稳定高频振动。 | 谐振开始受到干扰，但仍保持稳定。 |
| **50%-74%** | **混合波形** | **数据橙** (`#FF8800`) | 波形在正弦波和三角波之间混合，出现少量粒子脱离。 | 谐振失真加剧，出现明显的不和谐音。 |
| **25%-49%** | **锯齿波** | **错误红** (`#FF2244`) | 波形完全转变为尖锐的锯齿状，伴有明显的“数字衰变”粒子效果。 | 谐振被严重破坏，接近崩溃的边缘。 |
| **<25%** | **故障方波** | **错误红** + **故障洋红** (`#FF00AA`) | 波形变为不规则的方波，出现剧烈的画面抖动和 Glitch 特效，伴有心跳般的红色脉冲。 | 系统崩溃，谐振完全被噪音取代。 |

#### 节拍同步设计

为了实现“通感”的设计哲学，血条的动态与音乐节拍紧密同步。其整体振幅会跟随音乐的重拍（例如每小节的第一拍）产生一次显著的“呼吸”效果，即振幅瞬间增大10-15%后迅速回弹，以此在视觉上强化音乐节奏与玩家生存状态的内在联系。而在玩家受到伤害时，血条则会触发一次剧烈的、非同步的“故障”动画作为即时反馈：波形会瞬间扭曲，颜色闪烁为代表不和谐的**腐蚀紫** (`#8800FF`)，然后快速衰减回当前生命值所对应的正常状态。这种设计通过打破原有的节拍同步性，在视觉上生动地强调了“不和谐”的外部入侵感。

#### Godot 实现建议

在 Godot 中实现谐振完整度，建议以一个 `Control` 节点作为容器，利用其 `_draw()` 函数进行完全的自定义绘制。在 `_draw()` 方法内部，通过 `draw_polyline` 来生成波形。波形的Y坐标可以由一个 `sin()` 函数（对应高血量状态）和一个自定义的锯齿/方波函数（对应低血量状态）通过 `mix()` 函数混合而成，从而实现平滑的形态过渡。所有复杂的视觉效果，如辉光、颜色渐变、节拍脉动和故障特效，都应在一个应用于该控件的 `ShaderMaterial` 中完成。该着色器需要接收 `hp_ratio`、`beat_progress` 和 `time` 等 `uniform` 变量。辉光效果可以通过在片元着色器中计算当前像素与波形线条的距离来实现；而故障效果则可以在低血量时，通过在顶点着色器中对顶点位置 `VERTEX.x` 施加随机偏移，或在片元着色器中实现颜色通道分离（Chromatic Aberration）来达成。最后，一个 `hp_bar.gd` 脚本将负责监听来自 `GameManager` 的 `player_hp_changed` 和 `beat_tick` 信号，用以实时更新着色器的 `uniform` 变量，并调用 `queue_redraw()` 来刷新显示。


### 3.2. 听感疲劳指示器

听感疲劳是游戏的核心机制之一，其指示器旨在将抽象的“疲劳度”转化为一种持续的、不可忽视的视觉压力，时刻提醒玩家管理战斗节奏。

听感疲劳指示器被设计为一个持续的视觉压力源，其**布局位于屏幕右侧边缘**，使用 `Center-Right` 锚点。它呈现为一个细长的**垂直条状**，从屏幕的垂直中线对称地向上和向下延伸，便于玩家用余光快速扫视。其**基准尺寸**为 20px 宽度（不包含辉光效果）和 400px 高度。与血条类似，它也被放置在 `Layer 10` 的 `CanvasLayer` 上。

#### 状态变化的视觉表现

疲劳指示器通过颜色、形态和动态效果，直观反映听感疲劳指数 (AFI) 的累积程度。

| AFI 范围 | 形态 | 颜色 | 动画/VFX | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| **0.0 - 0.4** | **纤细光条** | **谐振青** (`#00FFD4`) | 光条平滑稳定，有微弱的呼吸光效。 | 听觉环境清澈，无压力。 |
| **0.4 - 0.6** | **加宽光条** | **Dominant 黄** (`#FFE066`) | 光条开始轻微抖动，边缘出现不稳定粒子。 | 开始出现听觉压力，需要玩家注意。 |
| **0.6 - 0.8** | **三角波形** | **数据橙** (`#FF8800`) | 光条边缘呈现出低频的三角波形态，抖动加剧。 | 显著的听觉疲劳，开始影响操作精度。 |
| **0.8 - 1.0** | **红色锯齿波** | **错误红** (`#FF2244`) | 光条完全变为高频、不规则的红色锯齿波，伴有强烈的 Glitch 效果和粒子喷发。 | 听觉过载，系统濒临崩溃，惩罚机制激活。 |

#### 节拍同步设计

该指示器同样与节拍深度同步。当听感疲劳指数 (AFI) 超过 0.6 后，其波形振幅和故障艺术（Glitch）的强度会开始与音乐节拍同步脉动。每一次重拍都会引发一次更强的视觉“故障”，从而在感官上加剧玩家的紧迫感。此外，该指示器的状态与名为 `fatigue_filter.gdshader` 的全屏后处理效果强关联，形成“源头”与“影响范围”的关系：指示器是疲劳状态的直接量度，而全屏的视觉恶化效果则是这种疲劳状态对玩家感知的全面影响的体现。

#### Godot 实现建议

对于听感疲劳指示器的实现，推荐使用 `TextureProgressBar` 节点，并为其 `texture_progress` 属性应用一个自定义的着色器。这种方法比手动 `_draw()` 更高效，并且能直接利用 `ProgressBar` 内置的 `value` 属性。该着色器是实现所有视觉效果的核心，需要接收 `afi_ratio`、`time` 和 `beat_intensity` 等 `uniform` 变量。在片元着色器中，可以利用 `step(fill_ratio, UV.x)` 创建基础的填充形状；通过在填充边界上叠加一个由 `sin(UV.y * frequency + time)` 计算出的偏移，可以生成动态的波形边缘；通过 `mix()` 函数则能根据 `afi_ratio` 实现平滑的颜色过渡。当 `afi_ratio` 接近 1.0 时，可以通过引入由 `hash` 函数和 `beat_intensity` 触发的随机 `UV` 偏移或颜色通道分离，来实现与节拍同步的故障效果。最后，`fatigue_meter.gd` 脚本负责监听 `FatigueManager.fatigue_updated` 信号，以实时更新 `ProgressBar` 的 `value` 和着色器的 `afi_ratio` uniform。


### 3.3. 序列器状态

此元素是玩家自动施法循环的实时视觉反馈，将音乐序列器的概念与战斗行为直接关联。它不是一个传统的屏幕空间UI，而是作为游戏世界的一部分，始终围绕着玩家角色。

序列器状态并非传统的屏幕空间 UI，而是作为游戏世界的一部分，其**布局以玩家角色为中心**，呈现为一个**环形刻度盘**。它的**尺寸**设定为半径约 1.5 至 2.0 游戏单位，旨在确保在常规游戏视角下清晰可见，同时不遮挡核心战斗区域。在**渲染层级**上，它是一个 `Node3D` 实例，被渲染在地面之上、角色实体之下。一种备选实现方案是使用一个跟随玩家的 `SubViewport` 将其渲染到纹理，再作为 `Sprite3D` 显示，以避免被其他视觉特效遮挡。

#### 视觉表现

序列器状态环是一个多层信息载体，展示了节拍、自动施法点和休止符。

| 元素 | 视觉样式 | 动画/VFX | 描述 |
| :--- | :--- | :--- | :--- |
| **刻度环** | 由 16 个独立的刻度标记组成的完整圆环，代表一个 4/4 拍的四小节序列。 | 整体环形会随着节拍有微弱的辉光脉动。 | 提供了序列的基本结构和时间参考。 |
| **节拍光标** | 一个明亮的**晶体白** (`#EAE6FF`) 光点。 | 光点在每个节拍的瞬间，从一个刻度“跳”到下一个刻度，完成一次完整的 360 度扫描恰好是 16 拍。 | 实时指示当前序列进行到的位置。 |
| **施法点** | 被放置了音符的刻度标记会高亮显示为该音符对应的颜色（如 C 为**谐振青**）。 | 当节拍光标扫过施法点时，该点会瞬间闪耀，并触发一个向外的粒子爆发效果，与实际的法术发射同步。 | 明确指示下一次自动施法的内容和时机。 |
| **休止符** | 未放置音符的刻度标记则显示为暗淡的**星空紫** (`#141026`)。 | 无特殊效果，仅作为序列中的“静默”部分。 | 表示该节拍上无自动施法事件。 |

#### Godot 实现建议

序列器状态环的实现建议以一个 `Node3D` 作为根节点，通过脚本在运行时动态生成 16 个 `MeshInstance3D` 作为刻度标记，以及一个额外的 `MeshInstance3D` 作为节拍光标。所有这些网格实例都应使用 `ShaderMaterial` 以实现动态效果。刻度标记的着色器可以接收一个 `note_color` uniform，使其在有音符时显示亮色，无音符时显示暗紫色。当节拍光标扫过某个刻度时，脚本可以向该刻度的着色器传递一个 `hit_intensity` uniform，以触发其短暂的闪耀和放大动画。最后，一个 `sequencer_ui.gd` 脚本将作为总控制器，负责监听 `GameManager` 的 `beat_tick` 信号，并根据节拍计数器更新光标位置及触发相应的视觉特效。

### 3.4. 手动施法槽

为玩家提供即时、高响应度的战术选择，是传统游戏操作习惯的保留，但融入了项目独特的美术风格。

手动施法槽为玩家提供了即时的战术选择，其**布局遵循传统游戏习惯，位于屏幕左下角**，并使用 `Bottom-Left` 锚点。其**整体尺寸**约为 240x80 像素，内部水平排列着三个 64x64 像素的方形槽位。它被放置在 `Layer 10` 的 `CanvasLayer` 上。

#### 视觉表现

| 状态 | 视觉样式 | 动画/VFX | 描述 |
| :--- | :--- | :--- | :--- |
| **可用** | 槽位图标清晰明亮，边框为**主强调色** (`#9D6FFF`) 并伴有微弱辉光。 | 槽位背景有缓慢流动的电流特效，表示能量充盈。 | 法术已就绪，随时可以施放。 |
| **冷却中** | 图标被一个从上至下填充的半透明**深渊黑** (`#0A0814`) 遮罩覆盖，遮罩上用**晶体白**显示剩余冷却时间数字。 | 冷却完成时，遮罩瞬间消失，并伴有一个小型的“电力涌动”粒子效果和边框闪烁。 | 法术正在冷却，不可使用。 |
| **法力不足** | 槽位整体变为红色，图标闪烁。 | 无。 | 玩家没有足够的资源来施放该法术。 |

#### Godot 实现建议

手动施法槽的实现可以从一个 `HBoxContainer` 开始，其内部包含三个代表槽位的自定义 `Control` 节点。每个槽位内部由 `TextureRect`（图标）、`ColorRect`（冷却遮罩）和 `Label`（冷却时间）共同搭建而成。平滑的冷却填充动画可以通过 `Tween` 或 `AnimationPlayer` 来控制冷却遮罩 `ColorRect` 的 `scale.y` 属性或一个自定义的着色器 uniform 来实现。对于“可用”状态下的背景电流特效，可以为槽位背景应用一个流动噪声着色器，并通过 `TIME` uniform 驱动其滚动，以低成本模拟出动态的能量感。

### 3.5. 信息面板

提供必要的环境和进度数据，设计上力求简洁、易读，不干扰核心战斗视野。

信息面板用于提供辅助性的环境和进度数据，其设计力求简洁。**布局位于屏幕左上角**，使用 `Top-Left` 锚点，以避免干扰玩家的核心视野。其**尺寸**约为 200x100 像素，同样位于 `Layer 10` 的 `CanvasLayer` 上。

#### 视觉表现

采用垂直列表布局，每个信息项由“标签”和“数值”组成。

信息面板采用垂直列表布局，清晰地展示了四个关键数据项：**BPM** (Beats Per Minute) 实时显示当前背景音乐的节拍速率；**Time** 记录本局游戏已进行的时长；**Level** 显示玩家当前等级；**Enemies** 则显示屏幕上存在的敌人数量。

所有文本均使用**晶体白** (`#EAE6FF`)，字体为清晰的无衬线或等宽字体。面板背景为标准的**星空紫** (`#141026`)，80%不透明度，带有1px的**主强调色**边框。

#### Godot 实现建议

信息面板的实现相对直接，可以使用一个 `PanelContainer` 作为背景，其内部放置一个 `VBoxContainer` 来垂直组织信息项。每个信息项本身是一个 `HBoxContainer`，包含两个 `Label` 节点（一个用于标签，一个用于数值）。所有的数据更新逻辑都应在主 `hud.gd` 脚本中处理，通过监听如 `GameManager.level_up` 等信号或使用定时器来更新这些 `Label` 的文本。为了避免不必要的性能开销和视觉噪音，BPM 和敌人数量这类高频变化的数据建议每秒更新一次。

### 3.6. 伤害数字系统

伤害数字是战斗反馈的核心，其设计必须清晰、即时，并能通过视觉差异传达不同类型的伤害事件，增强玩家对战斗情况的理解。

伤害数字系统是战斗反馈的核心，其**布局位置是动态的**，总是在伤害事件发生的游戏世界坐标处生成。其**尺寸**也是动态的，字体大小会根据伤害数值进行调整，其中暴击伤害会以更大的字号显示以示强调。在**渲染层级**上，它们是游戏世界内的 `Node2D` 节点，位于 `Layer 6`，确保其能显示在大部分场景元素之上，但又在最顶层的屏幕空间UI之下。

#### 视觉表现

| 伤害/治疗类型 | 颜色 | 字体/VFX | 动画轨迹 | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| **普通伤害** | **晶体白** (`#EAE6FF`) | 简洁的无衬线字体。 | 快速向上直线浮动一小段距离后淡出。 | 提供基础、无干扰的伤害反馈。 |
| **暴击伤害** | **圣光金** (`#FFD700`) | 带有轻微“故障艺术”效果的字体，数字边缘有像素位移。 | 伴随一个金色的圆形**波纹**从数字中心扩散开来，数字本身在原地短暂停留、放大1.2倍后快速消散。 | 强调高额或特殊伤害，给予玩家强烈的满足感。 |
| **不和谐自伤** | **腐蚀紫** (`#8800FF`) | 带有“液体下滴”效果的扭曲字体。 | 数字生成后**向下流淌**一小段距离，如同滴落的液体，然后消失。 | 清晰地区分外部伤害和由玩家自身行为（如听感疲劳过高）导致的惩罚性伤害。 |
| **治疗** | **治愈绿** (`#66FFB2`) | 柔和、带有辉光的字体。 | 多个小的光点从周围**汇聚**到玩家身上，最终合并成治疗数字，然后缓慢向上浮动并淡出。 | 提供积极、舒缓的视觉反馈，与伤害的爆裂感形成对比。 |

#### Godot 实现建议

伤害数字系统的实现核心在于**对象池（Object Pooling）**技术。由于游戏中可能瞬间产生大量伤害数字，频繁实例化新节点会造成严重性能问题。因此，必须预先创建一定数量的伤害数字节点（例如，一个包含 `Label` 和 `AnimationPlayer` 的 `damage_number.tscn` 场景），并将它们置于一个池中进行复用。一个全局的 `DamageNumberManager` 单例将负责管理这个对象池，并在需要时取出、设置并激活一个伤害数字实例。每个伤害类型的独特动画轨迹、缩放和透明度变化可以通过 `AnimationPlayer` 或 `Tween` 来精确控制。对于暴击的故障效果和自伤的流淌效果，则可以为 `Label` 应用 `ShaderMaterial`，并通过在着色器中扰动 `UV` 或 `VERTEX` 坐标来实现。

### 3.7. Boss 血条主题化设计

Boss 战是游戏的高潮部分，其血条设计必须具有史诗感和独特性，以匹配每个音乐巨匠 Boss 的身份。

Boss 血条的设计旨在营造史诗感，其**布局位于屏幕正上方**，使用 `Top-Wide` 锚点，给玩家带来强烈的压迫感。其**整体尺寸**非常巨大，容器约为 1000x120 像素，而内部的血条本身尺寸约为 800x40 像素。它被放置在 `Layer 10` 的 `CanvasLayer` 上。

#### 视觉表现

每个 Boss 的血条都由一个独特的“容器”和内部流动的“能量”组成，能量的填充度代表 Boss 的剩余生命值。所有设计均遵循《美术与VFX方向总文档》的规范。

| Boss | 容器设计主题 | 能量流动色彩 | 视觉特征描述 |
| :--- | :--- | :--- | :--- |
| **毕达哥拉斯** | **克拉尼图形** | 谐振青 / 晶体白 | 边框由不断变化的、对称的克拉尼沙画图案构成，能量如稳定的声波般流动。 |
| **圭多** | **哥特拱门** | 暗红 / 圣光金 | 血条被置于一个华丽的哥特式尖顶拱门框架内，能量带有羊皮纸的质感和神圣的光辉。 |
| **巴赫** | **管风琴齿轮** | 黄铜 / 暗金 | 边框由精密的黄铜齿轮和管风琴的音管交错构成，能量流动时伴有齿轮转动的细微动画。 |
| **莫扎特** | **洛可可金框** | 象牙白 / 金色 | 血条被一个极其华丽、布满卷草纹和花饰的洛可可风格金色画框包围。 |
| **贝多芬** | **破碎岩石闪电** | 橙红 / 闪电白 | 边框是不断崩裂的岩石，时有闪电在裂缝中划过。能量如岩浆般粘稠，低血量时闪电会更加频繁。 |
| **爵士** | **霓虹灯管** | 霓虹蓝 / 粉色 | 整个血条由弯曲的霓虹灯管构成，边框和能量都在闪烁，带有独特的频闪和光晕效果。 |
| **噪音** | **故障像素** | 全频谱故障色 | 边框本身就是由不断解构和重组的像素块构成的，能量是混乱的数据流，充满了色彩分离和像素错位。 |

#### Godot 实现建议

Boss 血条的实现推荐使用一个 `TextureProgressBar`，并为其 `texture_progress`（前景）和 `texture_over`（背景）属性应用一个高度定制化的 `ShaderMaterial`，这种方法比用多个控件拼凑要灵活得多。一个统一的 `boss_hp_bar.gdshader` 将是实现所有 Boss 风格差异化的核心，它通过接收 `chapter_id`、`hp_ratio`、`time` 等 `uniform` 变量来切换内部的渲染逻辑。可以为每个 Boss 设计一个独特的灰度图作为容器形状和纹理的遮罩，在着色器中进行采样。而对于克拉尼图形、闪电、霓虹灯光晕等动态效果，则应在着色器中通过噪声函数（fbm, noise）、三角函数和 `TIME` 变量来程序化生成，以获得最佳性能和细节。最后，`boss_hp_bar_ui.gd` 脚本将在 Boss 战开始时，根据 `chapter_id` 设置好着色器所需的全部 `uniform` 参数，之后在战斗中仅需实时更新 `hp_ratio` 即可。

### 3.8. 弹药环形 HUD

此 HUD 将玩家的“弹药”或“音色”资源状态与序列器状态同心展示，强化了以玩家为中心的战斗信息体系。

弹药环形 HUD 与序列器状态环同心设计，强化了以玩家为中心的战斗信息体系。其**布局同样以玩家为中心**，位于“序列器状态”环的外圈。其**尺寸**更大，半径约为 2.5 至 3.0 游戏单位。它与序列器状态环位于同一**渲染层级**，即游戏世界内的 `Layer 5`。

#### 视觉表现

在视觉表现上，弹药环由多个独立的弧段共同组成一个完整的圆环，其中每个弧段代表一种已装备的“音色”或武器。弧段的填充长度直观地表示了该音色的剩余“弹药量”或可用能量；满弹药时弧段是完整的，随着消耗则从末端开始缩短。每个弧段的颜色都与其所代表的音色或音符的特征色相对应，例如 F 音符的弹药环为**深渊紫**。系统还提供了清晰的交互反馈：当玩家切换武器时，新激活的弧段会高亮闪烁；当某个音色的弹药完全耗尽时，其对应弧段会变为暗淡的灰色并闪烁红色，作为明确的资源枯竭警告。

#### Godot 实现建议

弹药环的实现方式类似于序列器状态环，可以从一个 `Node3D` 根节点开始通过脚本绘制。但考虑到需要绘制灵活的弧形，直接使用 `MeshInstance3D` 可能不太合适，更推荐的方案是使用 `ImmediateMesh` 进行动态网格生成，或者在一个 `Sprite3D` 的纹理上通过 `_draw()` 方法进行绘制。最高效的方案是开发一个能够绘制可变长度弧形的着色器，该着色器接收 `start_angle`、`end_angle`、`fill_ratio` 和 `color` 等 `uniform` 变量来精确绘制每个弧段。最后，一个 `ammo_ring_hud.gd` 脚本将负责管理所有弧段，它会从 `Player` 或 `WeaponManager` 获取实时的弹药信息，并据此更新每个弧段对应着色器的 `fill_ratio` uniform。

### 3.9. 召唤物 HUD

为玩家提供清晰的召唤物状态概览，便于管理和战术决策。

召唤物 HUD 为玩家提供清晰的召唤物状态概览，其**布局位于屏幕右上角**，使用 `Top-Right` 锚点。其**尺寸**约为 180x300 像素，整体呈现为一个**垂直排列的卡片列表**。它被放置在 `Layer 10` 的 `CanvasLayer` 上。

#### 视觉表现

其视觉表现为一系列垂直排列的卡片，每个激活的召唤物对应一张独立的卡片。卡片内部结构清晰，左侧是 48x48 像素的召唤物图标，右侧是其名称和当前等级，名称下方则是一个细长的水平进度条，用于显示其剩余存在时间。此外，卡片边框还能提供状态指示，例如当召唤物进入“狂暴”或“升级就绪”等特殊状态时，边框会闪烁特定颜色（如金色代表可升级）以吸引玩家注意。整个系统还包含流畅的过渡动画：召唤物生成时，其卡片会从屏幕外滑入列表；召唤物消失时，卡片则会以淡出或破碎的效果消失。

#### Godot 实现建议

召唤物 HUD 的实现可以使用一个 `VBoxContainer` 来自动管理所有召唤物卡片的布局。每个卡片本身是一个独立的场景 `SummonCard.tscn`，其内部由 `PanelContainer`、`TextureRect`、`Label` 和 `TextureProgressBar` 等标准控件构成。动态管理方面，`summon_hud.gd` 脚本将监听来自 `SummonManager` 的 `summon_created` 和 `summon_expired` 信号，在收到信号后相应地实例化或销毁卡片场景，并将其添加或移出 `VBoxContainer`。数据更新的职责则下放给每个 `SummonCard.gd` 脚本，由它负责从其对应的召唤物实例获取数据，并实时更新自身的持续时间进度条和状态显示。

### 3.10. 节拍指示器

节拍指示器是游戏节奏核心的最直接体现，为玩家提供了一个精确“卡拍”的视觉工具，是实现“完美节拍”奖励机制的基础。

节拍指示器是游戏节奏核心的最直接体现，其**布局位于游戏世界中玩家角色的正下方**，紧贴地面。其**尺寸**为一个直径约 2.0 游戏单位的环形。在**渲染层级**上，它通过 `Decal` 或 `Sprite3D` 实现，位于 `Layer 5`，确保被正确渲染在地面纹理之上。

#### 视觉表现

节拍指示器由一个静态的外环和一个动态的内缩环组成。

在视觉表现上，节拍指示器由两部分构成：一个静态的**外环**和一个动态的**内缩环**。外环是一个固定的、由刻度组成的**晶体白**圆环，代表一个节拍的完整时间周期，其中重拍位置的刻度会更亮或更长，以提供乐句的结构参考。内缩环则是一个**谐振青**色的圆环，其半径在每个节拍开始时重置为与外环相同的大小，然后在一个节拍的时间内均匀缩小至圆心。内缩环与圆心重合的瞬间，即是“完美节拍”的判定点。系统会根据玩家施法时机提供三种不同的视觉反馈：在精准时刻（如±50毫秒窗口）施法会被判定为**完美节拍**，指示器会迸发出一圈**圣光金**色的冲击波；在稍大的时间窗口内（如±100毫秒）施法，则为**良好节拍**，指示器会发出较弱的白色闪光；若在节拍点之外施法，则为**错过**，指示器不会有积极反馈，甚至可能闪烁红色以示惩罚。

#### Godot 实现建议

节拍指示器的实现推荐使用 `Sprite3D` 或 `Decal` 节点，并为其应用一个 `ShaderMaterial`。一个着色器即可负责绘制所有内容，包括静态外环和动态内缩环。该着色器需要接收 `beat_progress`（代表当前节拍进度的 0-1 值）、`flash_intensity` 和 `flash_color` 等 `uniform` 变量。在片元着色器中，可以通过计算像素 `UV` 坐标到中心的距离 `length(UV - center)` 并与半径比较，来绘制内外环。内缩环的半径可以直接通过 `outer_radius * (1.0 - beat_progress)` 计算得出。对于反馈的冲击波效果，当 `flash_intensity > 0` 时，可以绘制一个半径由 `flash_intensity` 控制、颜色为 `flash_color` 的外扩圆环，并通过 `Tween` 或 `AnimationPlayer` 快速将 `flash_intensity` 从 1 插值到 0 来实现。最后，`rhythm_indicator.gd` 脚本将监听 `GameManager.beat_tick` 信号来同步 `beat_progress`，同时监听玩家的输入事件以判断卡拍精度，并触发相应的着色器闪光效果。

### 3.11. 状态提示与警告

这些是高优先级的临时信息，用于就关键游戏事件向玩家发出明确的通知或警告。

状态提示与警告是最高优先级的临时信息，其**布局位置是动态的**，通常在屏幕中央或最需要玩家关注的信息焦点区域生成。其**尺寸**同样是动态的，会根据文本内容的长度自适应。为了确保绝对的可见性，它们被放置在**最高的渲染层级**，即 `Layer 11` 的 `CanvasLayer` 上，显示在所有其他UI元素之上。

#### 视觉表现

| 提示/警告类型 | 文本内容示例 | 颜色 | 字体/VFX | 动画 | 描述 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **密度过载警告** | `DENSITY OVERLOAD` | **错误红** | 粗大的故障艺术字体。 | 文本出现时伴随全屏的红色闪烁和轻微震动，文本本身也在不断地抖动和像素化。 | 当同屏敌人/弹幕密度超过危险阈值时显示，警告玩家即将进入高压环境。 |
| **和弦进行提示** | `CHORD PROGRESSION: I-V-vi-IV` | **圣光金** | 优雅的衬线字体，带有辉光。 | 文本从屏幕中央放大出现，短暂停留后化为光点消散。 | 当玩家成功打出特定的音符序列，触发了和弦进行奖励时显示。 |
| **单音寂静灰化指示** | `NOTE SILENCED: G` | **次级文本** (`#A098C8`) | 标准无衬线字体。 | 文本在屏幕下方血条附近淡入淡出。同时，所有与该音符相关的UI元素（如施法槽、弹药环）都会灰化。 | 当某个音符因为Boss机制或环境效果被禁用时，提供清晰的指示。 |

#### Godot 实现建议

状态提示与警告的实现建议通过一个全局的 `NotificationManager` 单例来管理。该管理器负责接收来自游戏中其他系统（如 `DensityManager`、`ChordManager`）的信号，并在需要时动态实例化一个包含 `Label` 和 `AnimationPlayer` 的 `Notification.tscn` 场景。`AnimationPlayer` 将负责处理文本的出现、停留和消失动画。对于“密度过载警告”的复杂特效，可以为 `Label` 应用一个专用的故障艺术着色器，并由 `AnimationPlayer` 控制其强度。而“单音寂静”的灰化效果，则可以通过为目标UI控件的 `material` 属性设置一个 `ShaderMaterial`，并在着色器中将其饱和度（`SATURATION`）设为 0 来统一实现。一个全局信号可以方便地通知所有相关的UI元素进行自我更新。

## 4. Godot 实现总览

为了高效、统一地实现上述复杂的 HUD 系统，我们确立了以 **Shader 驱动**和**数据驱动**为核心的实现策略。这种方法将视觉表现与游戏逻辑解耦，极大地提升了可维护性和迭代效率。

**核心技术栈**

- **`CanvasLayer`**: 所有屏幕空间的 UI 元素都应放置在不同的 `CanvasLayer` 中，以严格控制渲染顺序。高优先级的、需要覆盖所有内容的提示信息（如“密度过载警告”）应位于最高的 `Layer`。

- **自定义绘制 (`_draw`)**: 对于需要程序化生成复杂几何形状（如谐振完整度的弧形波浪）的控件，应创建一个继承自 `Control` 的新节点，并在其 `_draw()` 方法中使用 `draw_polyline`、`draw_rect` 等函数进行绘制。这为程序化生成图形提供了最大的灵活性。

- **着色器 (`ShaderMaterial`)**: 这是实现动态视觉效果的基石。UI 设计中超过 80% 的动态效果，包括颜色渐变、辉光、节拍脉动、故障艺术、波形变化等，都应在 `canvas_item` 类型的着色器中完成。通过向着色器传递 `uniform` 变量（如 `hp_ratio`, `beat_progress`, `time`），GDScript 代码仅负责更新状态数据，而将繁重的视觉计算完全交给 GPU，从而获得极高的性能。

- **数据管理器与信号**: 游戏的核心状态（如玩家生命值、听感疲劳指数、节拍信息）应由专门的单例管理器（如 `GameManager`, `FatigueManager`）进行维护。UI 控件不应直接轮询这些状态，而应通过连接这些管理器发射的**信号**（如 `hp_changed`, `fatigue_updated`）来被动地接收更新。这种观察者模式确保了代码的低耦合和高响应性。

- **对象池 (`Object Pooling`)**: 对于像伤害数字这样需要频繁创建和销毁的元素，必须采用对象池技术。通过预先创建一定数量的实例并重复使用它们，可以完全避免在游戏运行时动态分配和释放内存所带来的性能尖峰和卡顿，这对于要求流畅体验的音乐节奏游戏至关重要。

**推荐工作流**

1.  **搭建结构**: 使用 Godot 的内置控件（`PanelContainer`, `VBoxContainer`, `Label`, `TextureProgressBar` 等）快速搭建出 HUD 的静态布局和层级结构。
2.  **编写脚本**: 为每个核心 HUD 元素创建独立的 `.gd` 脚本，在 `_ready()` 函数中连接所需的全局信号。
3.  **开发着色器**: 为需要动态效果的控件创建 `.gdshader` 文件，并定义好所需的 `uniform` 变量。先在着色器中实现静态的视觉效果。
4.  **连接数据**: 在 GDScript 脚本中，根据接收到的信号更新 `uniform` 变量的值，并调用 `queue_redraw()` (对于自定义绘制) 或直接设置控件属性 (对于 `ProgressBar` 等)，将游戏逻辑数据与视觉表现连接起来。
5.  **优化迭代**: 使用 Godot 的性能分析工具检查 HUD 的性能开销，特别是 `_draw()` 函数和着色器的复杂度，确保其不会成为游戏的性能瓶瓶颈。

通过遵循这一工作流，我们可以构建一个既符合艺术方向要求，又具备高性能和良好扩展性的战斗 HUD 系统。

## 5. 参考资料

[1] Project Harmony GDD. "Art_And_VFX_Direction.md". gdszyy/project-harmony-gdd. 2026-02-11.
