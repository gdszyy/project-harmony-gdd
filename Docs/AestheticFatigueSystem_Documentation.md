# Project Harmony：听感疲劳计算模型设计与实现文档

**版本:** 2.1
**最后更新:** 2026-02-11
**状态:** 已实现
**作者：** Manus AI

---

## 1. 引言

本文档详细阐述了为 **Project Harmony** 游戏设计的“听感疲劳系统”（Aesthetic Fatigue System）的理论基础、计算模型、代码实现与使用方法。该系统是游戏的核心机制之一，旨在取代传统的冷却时间（Cooldown）或法力值（Mana）系统，通过量化玩家操作的“音乐单调性”，来动态地限制或鼓励玩家的法术选择，从而引导玩家在战斗中自然地创作出更富于变化和和谐感的乐曲。

该模型的设计严格遵循了用户提供的《音乐审美疲劳的计算模型》研究报告 [1] 中的核心理论，并将其适配于游戏实时计算的场景，实现了科学性与可玩性的统一。

## 2. 核心理论基础

本计算模型并非凭空创造，而是建立在心理声学与信息论的坚实基础之上。我们从研究报告 [1] 中提取并简化了最适用于游戏场景的几个核心概念，构建了一个多维度的量化框架。

### 2.1. 信息论：量化不可预测性

信息论为我们提供了衡量“单调”与“重复”的数学语言。我们将玩家的法术施放序列视为一个信息流，通过计算其熵值来评估其多样性。

> **核心思想：** 一个熵值低（不确定性低）的法术序列，意味着其模式高度可预测，这在听感上等同于“单调乏味”。

-   **香农熵 (Shannon Entropy):** 用于衡量一个变量的平均不确定性。在我们的模型中，它被用来计算**音高熵**（玩家使用了多少种不同的音符）、**节奏熵**（施法时间间隔是否富于变化）和**和弦熵**（和弦类型的多样性）。熵值越高，多样性越好，疲劳度越低。

-   **转移熵 (Transition Entropy):** 用于衡量序列的演变逻辑。它计算的是在已知当前音符的条件下，下一个音符的不确定性。如果玩家总是遵循固定的法术组合（如 A-B-A-B），其转移熵会极低，导致疲劳度上升。

### 2.2. 递归量化分析 (RQA) 与模式重复

为了捕捉更长序列的重复模式（例如，玩家反复使用一个四音符的“乐句”），我们引入了递归量化分析中的“递归率”（Recurrence Rate）概念。通过计算不同长度（n-gram）的子序列在历史记录中的重复程度，模型可以有效识别结构性的单调，这对应了研究报告中关于自相似矩阵（SSM）的分析 [1] 。

### 2.3. 时间衰减：模拟听觉记忆

人类的听觉记忆并非是线性的，最近听到的内容印象更深，而久远的内容会逐渐被遗忘。为了模拟这一“遗忘曲线”，模型中所有事件的权重都会随时间呈指数衰减。一个15秒前施放的法术对当前疲劳度的影响，远小于1秒前的法术。

### 2.4. 翁特曲线与疲劳等级

心理学中的翁特曲线（Wundt Curve）揭示了人类偏好与刺激复杂性之间的倒U型关系 [1] 。过于简单（单调）或过于复杂（混乱）的刺激都会导致负面体验。我们的疲劳等级（`FatigueLevel`）正是基于此理论设计，当计算出的“单调性”指数超过特定阈值时，系统会逐步施加从轻微到严重的惩罚，模拟滑向倒U曲线左侧的过程。

## 3. 听感疲劳指数 (AFI) 计算模型 (v2.0)

为了将上述理论融合成一个可计算的指标，我们设计了“听感疲劳指数”（Aesthetic Fatigue Index, AFI）。它是一个范围在 `[0.0, 1.0]` 之间的浮点数，其实时值决定了玩家当前的疲劳等级和所受的惩罚。

### 3.1. AFI 综合公式

AFI 是八个核心疲劳维度的加权总和。每个维度的“疲劳值”都被归一化到 `[0.0, 1.0]` 区间，其中 `0.0` 代表最高多样性（无疲劳），`1.0` 代表最低多样性（极度疲劳）。

```
AFI = w_p*F_pitch + w_t*F_transition + w_r*F_rhythm + w_c*F_chord + w_n*F_ngram + w_d*F_density + w_s*F_rest + w_u*F_sustained
```

| 权重 (w) | 疲劳分量 (F) | 描述 | 对应理论 [1] |
| :--- | :--- | :--- | :--- |
| `weight_pitch_entropy` | **音高疲劳 (F_pitch)** | `1.0 - 音高熵`。衡量玩家使用的音符（法术）是否足够多样。 | 香农熵 |
| `weight_transition_entropy` | **转移疲劳 (F_transition)** | `1.0 - 转移熵`。衡量法术序列是否陷入了可预测的固定模式。 | 转移熵 |
| `weight_rhythm_entropy` | **节奏疲劳 (F_rhythm)** | `1.0 - 节奏熵`。衡量施法的时间间隔（节奏型）是否单调。 | 节奏熵 |
| `weight_chord_diversity` | **和弦疲劳 (F_chord)** | `1.0 - 和弦熵`。衡量使用的和弦类型是否丰富，鼓励玩家探索不同和弦。 | 符号分析 |
| `weight_recurrence` | **模式疲劳 (F_ngram)** | `n-gram递归率`。直接量化短乐句（2-4个音符）的重复程度。 | 递归量化分析 (RQA) |
| `weight_density` | **密度疲劳 (F_density)** | 惩罚过高的施法频率，避免认知过载。 | 均匀信息密度 (UID) |
| `weight_rest_deficit` | **留白疲劳 (F_rest)** | 惩罚缺乏适当施法间歇的行为，奖励“呼吸感”。 | 休止美学 |
| `weight_sustained_pressure` | **持续压力 (F_sustained)** | 惩罚长时间不间断的施法，模拟感官适应。 | 听觉疲劳理论 |

这些权重（`w_p`, `w_t` 等）在 `FatigueConfig` 中均可配置，允许设计师根据游戏平衡性需求，调整不同单调行为的惩罚力度。

## 4. 系统架构与代码实现

代码实现的核心是 `AestheticFatigueEngine` 类，它被设计为一个自包含、易于集成的模块。以下是其主要组件的解析。

### 4.1. 核心类：`AestheticFatigueEngine`

这是疲劳计算的主引擎。游戏主循环只需与它进行交互。

-   **`__init__(self, config)`**: 初始化引擎，可传入一个 `FatigueConfig` 对象来定制系统行为。
-   **`record_spell(self, event)`**: 核心接口。每次玩家施法时，游戏系统应创建一个 `SpellEvent` 对象并调用此方法。它会更新内部历史记录，重新计算AFI，并返回一个包含完整分析结果的 `FatigueResult` 对象。
-   **`query_fatigue(self, current_time)`**: 一个只读接口，用于查询当前状态而不记录新事件，适合用于UI更新或AI决策。
-   **`get_note_fatigue_map(self, current_time)`**: 获取每个独立音符的疲劳度，可用于在UI上高亮显示过载的法术槽。

### 4.2. 配置类：`FatigueConfig`

这个 `dataclass` 包含了所有可调节的参数，使得游戏设计师无需修改代码即可轻松调整系统难度和手感。

**关键可调参数：**

| 参数 | 描述 |
| :--- | :--- |
| `window_duration` | 滑动窗口时长（秒），定义了系统的“记忆”长度。 |
| `decay_half_life` | 时间衰减半衰期（秒），决定了旧事件权重的下降速度。 |
| `weight_*` | AFI公式中八个维度的权重。 |
| `threshold_*` | 从`MILD`到`CRITICAL`四个疲劳等级的AFI阈值。 |
| `penalty_mode` | 惩罚模式，可在GDD中描述的三种方案（`WEAKEN`, `LOCKOUT`, `GLOBAL_DEBUFF`）之间切换。 |
| `weaken_multiplier_*` | 在`WEAKEN`模式下，不同疲劳等级对应的伤害削弱系数。 |

### 4.3. 数据结构

-   **`SpellEvent`**: 记录一次法术施放的所有相关信息，包括时间戳、音符、是否为和弦、和弦类型等。这是引擎的输入。
-   **`FatigueResult`**: 引擎计算的输出。它包含了AFI、疲劳等级、各维度分量、具体的惩罚效果（`PenaltyEffect`）以及给玩家的恢复建议（`recovery_suggestions`）。

## 5. 关键特性与使用指南

### 5.1. 惩罚模式

系统内置了GDD中定义的三种惩罚方案，可通过 `FatigueConfig` 的 `penalty_mode` 参数进行切换：

1.  **`PenaltyMode.WEAKEN` (默认):** 削弱模式。随着疲劳等级的提升，法术的伤害/效果会按百分比降低。
2.  **`PenaltyMode.LOCKOUT`:** 锁定模式。当疲劳达到`CRITICAL`等级时，过度使用的法术将被暂时禁用。
3.  **`PenaltyMode.GLOBAL_DEBUFF`:** 全局不和谐模式。疲劳指数会转化为一个全局的“不和谐度”，影响所有法术的性能，并可能伴随全局的视觉或音效变化。

### 5.2. 恢复建议

为了帮助玩家理解疲劳机制并主动摆脱单调，系统会根据当前疲劳的主要来源，动态生成可操作的恢复建议。v2.0 新增了针对密度和留白的建议，且优先级更高：

-   `“⏸ 暂停施法！你已经连续施法太久了，休息一下让旋律呼吸”` (当持续施法压力过高时)
-   `“🎵 放慢施法节奏，给音乐留出空间，不要连绵不绝”` (当事件密度过高时)
-   `“🔇 在乐句之间留出空隙，沉默也是音乐的一部分”` (当留白缺失时)

-   `“尝试使用新音符：E, G, A”` (当音高疲劳过高时)
-   `“打破当前的音符序列模式，尝试不同的组合顺序”` (当转移疲劳过高时)
-   `“改变施法节奏，尝试不同的时间间隔”` (当节奏疲劳过高时)

这些建议可以直接显示在游戏UI中，作为对玩家的引导。

### 5.3. 难度预设

为了方便快速配置，代码提供了四个难度预设的工厂函数：

-   `create_easy_config()`: 适合新手，疲劳积累慢，惩罚轻。
-   `create_normal_config()`: 默认配置，提供均衡的挑战。
-   `create_hard_config()`: 适合寻求挑战的玩家，疲劳积累快，惩罚重。
-   `create_maestro_config()`: 大师难度，模拟了“音乐专家更容易感到无聊”的特性，对单调性的容忍度极低。

### 5.4. 集成示例

将疲劳系统集成到游戏循环中非常直接：

```python
# 在游戏初始化时
from aesthetic_fatigue_system import AestheticFatigueEngine, create_normal_config, SpellEvent, Note

fatigue_engine = AestheticFatigueEngine(create_normal_config())

# 当玩家施放法术时 (例如，按下了'C'键)
current_game_time = get_game_time() # 获取当前游戏时间
spell_note = Note.C

# 1. 创建法术事件
event = SpellEvent(timestamp=current_game_time, note=spell_note)

# 2. 记录事件并获取疲劳结果
fatigue_result = fatigue_engine.record_spell(event)

# 3. 应用惩罚
damage = base_damage * fatigue_result.penalty.damage_multiplier
if fatigue_result.penalty.is_locked:
    # 阻止法术施放
    show_locked_effect()
else:
    # 施放法术
    cast_spell(damage)

# 4. 更新UI
update_fatigue_bar(fatigue_result.fatigue_index)
show_recovery_suggestions(fatigue_result.recovery_suggestions)
```

## 6. 演示场景分析 (v2.0)

`aesthetic_fatigue_system.py` 文件中的 v2.0 演示代码验证了模型在多种场景下的行为符合设计预期，特别是新增的“密度”与“留白”维度。

-   **场景3 (连绵不绝):** 即使音符多样，但因密度过高、缺乏停歇，AFI 依然会快速上升至 `MODERATE`，其中“密度疲劳”和“留白缺失疲劳”是主要贡献者。这证明了 v2.0 模型成功堵上了 v1.0 的漏洞。
-   **场景4 (有呼吸感):** 在乐句间插入了适当的停顿。结果显示，尽管施法总量相近，但 AFI 显著低于场景3，始终保持在 `MILD` 或 `NONE` 的健康水平，证明了系统对“音乐性”的奖励。
-   **场景8 (v1 vs v2 对比):** 该场景直观地展示了新维度的价值。对于一个“多样但密集”的序列，v1 的维度认为其“多样性良好”，而 v2 的新维度则准确地识别出“密度过高”和“缺乏留白”的问题，给出了合理的疲劳惩罚。

`aesthetic_fatigue_system.py` 文件中的演示代码验证了模型在多种场景下的行为符合设计预期。



## 7. 频谱相位系统整合：第九维度 —— 频谱偏移疲劳 (Spectrum Offset Fatigue)

随着频谱相位系统（共鸣切片）的引入，AFI 模型新增了第九个疲劳维度。该维度专门用于防止玩家滥用极端相位（高通/低通）的战术优势，确保相位切换始终是一种“战术爆发”而非“持续状态”。

### 7.1. 更新后的 AFI 公式

```
AFI = w_p*F_pitch + w_t*F_transition + w_r*F_rhythm + w_c*F_chord + w_n*F_ngram 
    + w_d*F_density + w_s*F_rest + w_u*F_sustained + w_sp*F_spectrum
```

| 权重 (w) | 疲劳分量 (F) | 描述 | 对应理论 |
| :--- | :--- | :--- | :--- |
| `weight_spectrum_offset` | **频谱偏移疲劳 (F_spectrum)** | 玩家停留在极端相位（高通/低通）的累计时间。 | 频谱平衡理论 |

### 7.2. 计算规则

频谱偏移疲劳的计算与其他八个维度有本质区别：它不基于施法事件，而是基于玩家的相位停留时间。

- **积累规则**：只要玩家处于高通或低通相位，`F_spectrum` 就会以 **0.05/秒** 的速度线性增长。
- **衰减规则**：只有在全频相位下，`F_spectrum` 才会以 **0.08/秒** 的速度线性衰减。
- **临界触发**：当 `F_spectrum` 超过 **0.7** 时，触发“**频谱失调 (Spectrum Corruption)**”全局 Debuff：屏幕剧烈扭曲，所有音色效果暂时失效，直到玩家返回全频相位并将 `F_spectrum` 降至 **0.3** 以下。

### 7.3. 与相位能量的协同

频谱偏移疲劳与相位能量 (Phase Energy) 构成双重约束：

| 资源 | 约束类型 | 效果 |
| :--- | :--- | :--- |
| **相位能量** | 短期约束 | 能量耗尽时强制返回全频相位 |
| **频谱偏移疲劳** | 长期约束 | 累计过高时触发全局 Debuff |

相位能量是“硬性”约束，能量耗尽就无法继续使用极端相位；频谱偏移疲劳是“软性”约束，它不会直接禁止玩家使用极端相位，但会通过提升整体 AFI 来加剧所有其他疲劳维度的惩罚效果。两者共同作用，确保玩家必须将极端相位作为战术爆发手段而非持续状态。

详细的频谱相位系统设计请参阅 [ResonanceSlicing_System_Design.md](ResonanceSlicing_System_Design.md)。

---

## 8. 结论

本听感疲劳计算模型成功地将抽象的音乐审美理论转化为一套具体、可配置、可实时计算的游戏机制。它通过多维度分析玩家的操作序列，构建了一个与人类直觉高度相关的“单调性”量化指标AFI，为《Project Harmony》的核心玩法提供了坚实的理论与技术支持。该系统不仅能有效防止玩家采用单调的最优策略，更能通过其内在机制，引导玩家在追求战斗效率的同时，自然地进行一场富有创造性的音乐谱写。

---

## 参考文献

[1] Manus AI. (2026). *音乐审美疲劳的计算模型：从心理声学特征到高维隐空间动力学的单调性量化研究*. Project Harmony GDD 附属文档。
